name: Build ECMWF 250mb Wind Tiles

on:
  schedule:
    - cron: "30 */6 * * *"
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install system tools
        run: |
          sudo apt-get update
          sudo apt-get install -y gdal-bin

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python dependencies
        run: |
          pip install numpy xarray cfgrib eccodes rasterio matplotlib requests pandas ecmwf-opendata

      - name: Download latest available ECMWF (High Res) + set ECMWF_VALID_UTC
        run: |
          set -e
          mkdir -p data

          python3 << 'EOF'
          from ecmwf.opendata import Client
          from datetime import datetime, timedelta
          import os
          import xarray as xr

          client = Client()

          out_path = "data/ecmwf.grib2"
          env_path = os.environ.get("GITHUB_ENV")

          def validate_grib(path: str) -> bool:
            try:
              for sn in ("u", "v"):
                ds = xr.open_dataset(
                  path,
                  engine="cfgrib",
                  backend_kwargs={
                    "filter_by_keys": {"typeOfLevel": "isobaricInhPa", "shortName": sn},
                    "indexpath": ""
                  },
                )
                if sn not in ds:
                  return False
                # must be able to select 250 hPa without error
                _ = ds[sn].sel(isobaricInhPa=250)
              return True
            except Exception as e:
              print(f"Validation failed: {e}")
              return False

          def attempt(date_str, hour):
            print(f"Trying ECMWF: {date_str} {hour:02d}z")
            if os.path.exists(out_path):
              os.remove(out_path)

            client.retrieve(
              date=date_str,
              time=hour,
              step=0,
              type="fc",
              levtype="pl",
              levelist=250,
              param=["u", "v"],
              resol="0p25",
              target=out_path
            )

            try:
              sz = os.path.getsize(out_path)
            except Exception:
              sz = 0

            print(f"Downloaded size: {sz} bytes")

            # ECMWF u/v @ 250mb can be ~1â€“2 MB. Size check is minimal; real check is cfgrib validation.
            if sz < 200_000:
              print("Too small; treating as failure.")
              return False

            if validate_grib(out_path):
              print("Validation OK.")
              return True

            print("Validation NOT OK; treating as failure.")
            return False

          # pick cycles (00/12) with a little lag for publishing
          now = datetime.utcnow() - timedelta(hours=6)
          today = now.strftime("%Y%m%d")
          yday = (now - timedelta(days=1)).strftime("%Y%m%d")

          candidates = [
            (today, 12),
            (today, 0),
            (yday, 12),
            (yday, 0),
          ]

          ok = False
          chosen = None

          for date_str, hour in candidates:
            try:
              if attempt(date_str, hour):
                ok = True
                chosen = f"{date_str}{hour:02d}"
                break
            except Exception as e:
              print(f"Attempt failed: {e}")

          if not ok:
            raise SystemExit("ERROR: Could not download any candidate ECMWF cycle.")

          if env_path:
            with open(env_path, "a", encoding="utf-8") as f:
              f.write(f"ECMWF_VALID_UTC={chosen}\n")

          print(f"Using ECMWF_VALID_UTC={chosen}")
          EOF

      - name: Generate ECMWF 250mb GeoTIFFs (Raw + Color)
        run: |
          python << 'EOF'
          import xarray as xr
          import numpy as np
          import rasterio
          from rasterio.transform import from_origin
          import matplotlib
          matplotlib.use("Agg")
          import matplotlib.pyplot as plt
          import matplotlib.colors as mcolors
          import os

          WEBMERC_MAXLAT = 85.05112878

          if not os.path.exists("data/ecmwf.grib2"):
              raise SystemExit("ERROR: data/ecmwf.grib2 not found.")

          ds_u = xr.open_dataset(
              "data/ecmwf.grib2",
              engine="cfgrib",
              backend_kwargs={
                  "filter_by_keys": {"typeOfLevel": "isobaricInhPa", "shortName": "u"},
                  "indexpath": ""
              },
          )
          ds_v = xr.open_dataset(
              "data/ecmwf.grib2",
              engine="cfgrib",
              backend_kwargs={
                  "filter_by_keys": {"typeOfLevel": "isobaricInhPa", "shortName": "v"},
                  "indexpath": ""
              },
          )

          u = ds_u["u"].sel(isobaricInhPa=250)
          v = ds_v["v"].sel(isobaricInhPa=250)

          # m/s -> kt
          speed = np.sqrt(u**2 + v**2) * 1.94384

          # normalize lon to [-180, 180], sort, clip to WebMerc
          speed = speed.assign_coords(
              longitude=(((speed.longitude + 180) % 360) - 180)
          ).sortby("longitude").sortby("latitude", ascending=False)
          speed = speed.sel(latitude=slice(WEBMERC_MAXLAT, -WEBMERC_MAXLAT))

          lats = speed.latitude.values
          lons = speed.longitude.values
          dx = float(abs(lons[1] - lons[0]))
          dy = float(abs(lats[1] - lats[0]))
          transform = from_origin(float(lons.min()), float(lats.max()), dx, dy)

          # RAW
          with rasterio.open(
              "ecmwf_output_250mb_speed.tif",
              "w",
              driver="GTiff",
              height=speed.shape[0],
              width=speed.shape[1],
              count=1,
              dtype="float32",
              crs="EPSG:4326",
              transform=transform,
              nodata=np.nan,
          ) as dst:
              dst.write(speed.values.astype("float32"), 1)

          # COLOR
          vmin, vmax = 20.0, 225.0
          data = np.clip(speed.values, vmin, vmax)
          norm = np.clip((data - vmin) / (vmax - vmin), 0.0, 1.0)

          turbo = plt.get_cmap("turbo")
          colors = turbo(np.linspace(0, 1, 255))
          white = np.array([[1, 1, 1, 1]])
          new_colors = np.vstack((colors, white))
          cmap = mcolors.LinearSegmentedColormap.from_list("TurboWhite", new_colors)

          rgb = (cmap(norm)[..., :3] * 255).astype("uint8")

          with rasterio.open(
              "ecmwf_output_250mb_color.tif",
              "w",
              driver="GTiff",
              height=rgb.shape[0],
              width=rgb.shape[1],
              count=3,
              dtype="uint8",
              crs="EPSG:4326",
              transform=transform,
          ) as dst:
              dst.write(rgb[:, :, 0], 1)
              dst.write(rgb[:, :, 1], 2)
              dst.write(rgb[:, :, 2], 3)

          print("GeoTIFFs written successfully")
          EOF

      - name: Generate map tiles (zoom 0-4)
        run: |
          rm -rf tiles/ecmwf/latest
          mkdir -p tiles/ecmwf/latest
          gdal2tiles.py --profile=mercator --xyz -r bilinear -z 0-4 \
            ecmwf_output_250mb_color.tif tiles/ecmwf/latest
          date > tiles/ecmwf/latest/last_update.txt

      - name: Update Dataset (Fill ECMWF Data)
        run: |
          set -e
          if [ -f "data/raob/latest.json" ]; then
            python scripts/build_raob_250mb_dataset.py \
              --in "data/raob/latest.json" \
              --out "data/raob/latest.json" \
              --ecmwf-tif ecmwf_output_250mb_speed.tif \
              --ecmwf-units kt
          else
            echo "WARNING: data/raob/latest.json not found. Skipping merge."
          fi

      - name: Commit updated ECMWF tiles + dataset
        shell: bash
        run: |
          set -euo pipefail

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git fetch origin main
          git checkout main
          git pull --rebase origin main

          git add tiles/ecmwf/latest tiles/ecmwf/latest/last_update.txt data/raob/latest.json || true

          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          git commit -m "Update ECMWF 250mb tiles + dataset (${ECMWF_VALID_UTC:-unknown})"

          for attempt in 1 2 3; do
            if git push origin HEAD:main; then
              echo "Push succeeded."
              exit 0
            fi
            echo "Push rejected (non-fast-forward). Rebasing and retrying... attempt ${attempt}"
            git fetch origin main
            git pull --rebase origin main
          done

          echo "ERROR: push failed after retries."
          exit 1
